# File: app.py
# Deskripsi: Aplikasi web Flask untuk watermarking dokumen .docx dengan QR Code LSB.

import os
import subprocess
import uuid
import shutil
from flask import Flask, render_template, request, jsonify, send_from_directory
from PIL import Image
import numpy as np
import json
import time

from main import extract_images_from_docx, embed_watermark_to_docx
from qr_utils import read_qr


# Inisialisasi aplikasi Flask
app = Flask(__name__)

# Konfigurasi path
BASE_DIR = os.path.abspath(os.path.dirname(__file__))
UPLOAD_FOLDER = os.path.join(BASE_DIR, 'static', 'uploads')
GENERATED_FOLDER = os.path.join(BASE_DIR, 'static', 'generated')
DOCUMENTS_FOLDER = os.path.join(BASE_DIR, 'public', 'documents')
MAIN_SCRIPT_PATH = os.path.join(BASE_DIR, 'main.py')

os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(GENERATED_FOLDER, exist_ok=True)
os.makedirs(DOCUMENTS_FOLDER, exist_ok=True)

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['GENERATED_FOLDER'] = GENERATED_FOLDER
app.config['DOCUMENTS_FOLDER'] = DOCUMENTS_FOLDER
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # Batas unggah 16MB

ALLOWED_DOCX_EXTENSIONS = {'docx', 'pdf'}
ALLOWED_IMAGE_EXTENSIONS = {'png'}


def allowed_file(filename, allowed_extensions):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in allowed_extensions


def get_file_size_info(file_path):
    """
    Mendapatkan informasi ukuran file dalam berbagai format.
    
    Args:
        file_path (str): Path ke file yang akan dianalisis
    
    Returns:
        dict: Informasi ukuran file dalam bytes, KB, MB
    """
    if not os.path.exists(file_path):
        return {"bytes": 0, "kb": 0, "mb": 0, "formatted": "File tidak ditemukan"}
    
    size_bytes = os.path.getsize(file_path)
    size_kb = size_bytes / 1024
    size_mb = size_bytes / (1024 * 1024)
    
    # Format yang mudah dibaca
    if size_mb >= 1:
        formatted_size = f"{size_mb:.2f} MB"
    elif size_kb >= 1:
        formatted_size = f"{size_kb:.2f} KB"
    else:
        formatted_size = f"{size_bytes} bytes"
    
    return {
        "bytes": size_bytes,
        "kb": round(size_kb, 2),
        "mb": round(size_mb, 2),
        "formatted": formatted_size
    }


def calculate_file_size_comparison(original_path, processed_path):
    """
    Membandingkan ukuran file sebelum dan sesudah proses.
    
    Args:
        original_path (str): Path file asli
        processed_path (str): Path file hasil proses
    
    Returns:
        dict: Informasi perbandingan ukuran file
    """
    original_info = get_file_size_info(original_path)
    processed_info = get_file_size_info(processed_path)
    
    if original_info["bytes"] == 0 or processed_info["bytes"] == 0:
        return {
            "original": original_info,
            "processed": processed_info,
            "difference_bytes": 0,
            "difference_percentage": 0,
            "size_change": "Tidak dapat menghitung"
        }
    
    # Hitung selisih
    difference_bytes = processed_info["bytes"] - original_info["bytes"]
    difference_percentage = (difference_bytes / original_info["bytes"]) * 100
    
    # Tentukan jenis perubahan
    if difference_bytes > 0:
        size_change = f"Bertambah {abs(difference_percentage):.2f}%"
    elif difference_bytes < 0:
        size_change = f"Berkurang {abs(difference_percentage):.2f}%"
    else:
        size_change = "Tidak berubah"
    
    return {
        "original": original_info,
        "processed": processed_info,
        "difference_bytes": difference_bytes,
        "difference_percentage": round(difference_percentage, 2),
        "size_change": size_change
    }


def run_main_script(args):
    """Menjalankan skrip main.py dan menangkap output."""
    command = ['python', MAIN_SCRIPT_PATH] + args
    try:
        result = subprocess.run(command, capture_output=True, text=True, check=True, encoding='utf-8')
        return {"success": True, "stdout": result.stdout, "stderr": result.stderr}
    except subprocess.CalledProcessError as e:
                pass
        return {"success": False, "stdout": e.stdout, "stderr": e.stderr, "error": str(e)}
    except FileNotFoundError:
        error_msg = "[!] Error: Perintah 'python' atau skrip 'main.py' tidak ditemukan. Pastikan Python terinstal dan path sudah benar."
        print(error_msg)
        return {"success": False, "stdout": "", "stderr": error_msg, "error": error_msg}
    except Exception as e:
                pass
        error_msg = f"[!] Exception saat menjalankan skrip: {str(e)}"
        print(error_msg)
        return {"success": False, "stdout": "", "stderr": error_msg, "error": error_msg}


def calculate_metrics(original_docx_path, stego_docx_path):
    """Menghitung MSE dan PSNR antara gambar-gambar dalam dua file .docx."""

    try:
        # Ekstrak gambar dari kedua dokumen
        original_images_dir = os.path.join(app.config['GENERATED_FOLDER'], "original_images")
        stego_images_dir = os.path.join(app.config['GENERATED_FOLDER'], "stego_images")
        os.makedirs(original_images_dir, exist_ok=True)
        os.makedirs(stego_images_dir, exist_ok=True)

        original_images = extract_images_from_docx(original_docx_path, original_images_dir)
        stego_images = extract_images_from_docx(stego_docx_path, stego_images_dir)

        if not original_images or not stego_images:
            return {"mse": 0.0, "psnr": 0.0, "error": "Gagal mengekstrak gambar dari dokumen."}

        if len(original_images) != len(stego_images):
            return {"mse": 0.0, "psnr": 0.0, "error": "Jumlah gambar tidak sama."}

        total_mse = 0
        all_psnr_values = []

        for original_image_path, stego_image_path in zip(original_images, stego_images):
            try:
                original_image = Image.open(original_image_path).convert('RGB')
                stego_image = Image.open(stego_image_path).convert('RGB')

                if original_image.size != stego_image.size:
                    continue  # Lewati pasangan gambar ini

                original_array = np.array(original_image, dtype=np.float64)
                watermarked_array = np.array(stego_image, dtype=np.float64)

                mse = np.mean((original_array - watermarked_array) ** 2)
                total_mse += mse

                # Robust PSNR calculation with error handling
                try:
                    if mse == 0:
                        psnr = 999.99  # Perfect quality
                    else:
                        max_pixel = 255.0
                        sqrt_mse = np.sqrt(mse)
                        if sqrt_mse == 0:
                            psnr = 999.99
                        else:
                            log_val = max_pixel / sqrt_mse
                            if log_val <= 0:
                                psnr = 0  # Very poor quality
                            else:
                                psnr = 10 * np.log10((max_pixel_value ** 2) / mse)
                                # Clamp PSNR to reasonable range
                                psnr = max(0, min(psnr, 999.99))
                    
                    all_psnr_values.append(psnr)
                except Exception as psnr_error:
                    all_psnr_values.append(0)  # Default to poor quality

            except Exception as e:
                pass
                continue

        # Robust final calculations with error handling
        try:
            final_mse = total_mse / len(original_images) if original_images else 0
            final_mse = max(0, final_mse)  # Ensure non-negative
        except Exception:
            final_mse = 0
            
        try:
            final_psnr = sum(all_psnr_values) / len(all_psnr_values) if all_psnr_values else 0
            # Ensure PSNR is in valid range
            final_psnr = max(0, min(final_psnr, 999.99))
        except Exception:
            final_psnr = 0

        # Bersihkan direktori sementara
        if os.path.exists(original_images_dir):
            shutil.rmtree(original_images_dir)
        if os.path.exists(stego_images_dir):
            shutil.rmtree(stego_images_dir)

        return {"mse": final_mse, "psnr": final_psnr}

    except Exception as e:
                pass
        import traceback
        traceback.print_exc()
        return {"mse": 0.0, "psnr": 0.0, "error": str(e)}


@app.route('/')
def index():
    return render_template('index.html')


@app.route('/generate_qr', methods=['POST'])
def generate_qr_route():
    data = request.form.get('qrData')
    if not data:
        return jsonify({"success": False, "message": "Data QR tidak boleh kosong."}), 400

    qr_filename = f"qr_{uuid.uuid4().hex}.png"
    qr_output_path = os.path.join(app.config['GENERATED_FOLDER'], qr_filename)

    # Import fungsi CRC32
    from qr_utils import add_crc32_checksum
    
    try:
        # Tambahkan CRC32 checksum
        data_with_checksum = add_crc32_checksum(data)
        
        # Konversi ke JSON
        qr_data_json = json.dumps(data_with_checksum, separators=(',', ':'))
        
        # Generate QR Code dengan checksum
        args = ['generate_qr', '--data', qr_data_json, '--output', qr_output_path]
        result = run_main_script(args)

        if result["success"] and os.path.exists(qr_output_path):
            return jsonify({
                "success": True,
                "message": "QR Code berhasil dibuat dengan CRC32 checksum!",
                "qr_url": f"/static/generated/{qr_filename}",
                "qr_filename": qr_filename,
                "log": result["stdout"],
                "crc32_info": {
                    "checksum": data_with_checksum.get('crc32'),
                    "data_length": len(data),
                    "integrity_protected": True
                }
            })
        else:
            return jsonify({
                "success": False,
                "message": "Gagal membuat QR Code.",
                "log": result["stderr"] or result.get("error", "Error tidak diketahui")
            }), 500
            
    except Exception as e:
                pass
        return jsonify({
            "success": False,
            "message": f"Error menambahkan CRC32: {str(e)}"
        }), 500


@app.route('/embed_docx', methods=['POST'])
def embed_docx_route():

    if 'docxFileEmbed' not in request.files or 'qrFileEmbed' not in request.files:
        error_msg = "File Dokumen dan File QR Code diperlukan."


        return jsonify({"success": False, "message": error_msg}), 400

    docx_file = request.files['docxFileEmbed']
    qr_file = request.files['qrFileEmbed']

    if docx_file.filename == '' or qr_file.filename == '':
        error_msg = "Nama file tidak boleh kosong."
        return jsonify({"success": False, "message": error_msg}), 400

    if not (docx_file and allowed_file(docx_file.filename, ALLOWED_DOCX_EXTENSIONS)):
        error_msg = "Format Dokumen harus .docx atau .pdf"
        return jsonify({"success": False, "message": error_msg}), 400
    if not (qr_file and allowed_file(qr_file.filename, ALLOWED_IMAGE_EXTENSIONS)):
        error_msg = "Format QR Code harus .png"
        return jsonify({"success": False, "message": error_msg}), 400

    file_extension = docx_file.filename.rsplit('.', 1)[1].lower()
    docx_filename = f"doc_embed_in_{uuid.uuid4().hex}.{file_extension}"
    qr_embed_filename = f"qr_embed_in_{uuid.uuid4().hex}.png"
    docx_temp_path = os.path.join(app.config['UPLOAD_FOLDER'], docx_filename)
    qr_temp_path = os.path.join(app.config['UPLOAD_FOLDER'], qr_embed_filename)
    docx_file.save(docx_temp_path)
    qr_file.save(qr_temp_path)

    # Simpan ukuran file asli sebelum diproses
    original_file_size = get_file_size_info(docx_temp_path)

    stego_docx_filename = f"stego_doc_{uuid.uuid4().hex}.{file_extension}"
    stego_docx_output_path = os.path.join(app.config['GENERATED_FOLDER'], stego_docx_filename)
    
    # Juga siapkan path untuk dokumen hasil di folder documents
    documents_filename = f"watermarked_{uuid.uuid4().hex}.{file_extension}"
    documents_output_path = os.path.join(app.config['DOCUMENTS_FOLDER'], documents_filename)
    
    # Cek apakah file adalah PDF
    is_pdf = file_extension == 'pdf'
    
    if is_pdf:
        # Proses PDF menggunakan pdf_utils
        from pdf_utils import embed_watermark_to_pdf_real_images, create_watermarked_pdf
        
        # Buat direktori untuk proses PDF
        pdf_process_dir = os.path.join(app.config['GENERATED_FOLDER'], f"pdf_process_{uuid.uuid4().hex}")
        os.makedirs(pdf_process_dir, exist_ok=True)
        
        # Embed watermark ke gambar asli dalam PDF
        pdf_result = embed_watermark_to_pdf_real_images(docx_temp_path, qr_temp_path, pdf_process_dir)
        
        if not pdf_result.get("success"):
            return jsonify({
                "success": False,
                "message": pdf_result.get("message", "Gagal memproses PDF"),
                "error_type": pdf_result.get("error_type", "PDF_PROCESSING_ERROR")
            }), 500
        
        # Buat PDF baru dari gambar watermarked  
        watermarked_pdf_created = create_watermarked_pdf(
            docx_temp_path, 
            pdf_result["output_directories"]["watermarked_images"], 
            stego_docx_output_path
        )
        
        if not watermarked_pdf_created:
            return jsonify({
                "success": False,
                "message": "Gagal membuat PDF watermarked",
                "error_type": "PDF_CREATION_ERROR"
            }), 500
        
        result = {"success": True, "stdout": "PDF watermarking berhasil", "stderr": ""}
        process_result = pdf_result
        
    else:
        # Proses DOCX seperti biasa
        args = ['embed_docx', '--docx', docx_temp_path, '--qr', qr_temp_path, '--output', stego_docx_output_path]
        result = run_main_script(args)
        process_result = None

    if result["success"]:
        
        # Get processed images info
        if is_pdf and process_result:
            # Untuk PDF, konversi path ke format relatif yang benar
            raw_processed_images = process_result.get("processed_images", [])
            processed_images = []
            
            # Ambil nama direktori dari path output PDF
            pdf_dir_name = os.path.basename(pdf_process_dir)
            
            for img_info in raw_processed_images:
                # Salin file ke direktori public untuk akses web
                img_index = img_info.get("image_index", 1) - 1
                original_filename = img_info.get("original_filename", f"original_{img_index}.png")
                watermarked_filename = img_info.get("watermarked_filename", f"watermarked_{img_index}.png")
                
                # Path untuk public access
                original_public_path = os.path.join(app.config['GENERATED_FOLDER'], pdf_dir_name, original_filename)
                watermarked_public_path = os.path.join(app.config['GENERATED_FOLDER'], pdf_dir_name, watermarked_filename)
                
                # Salin file dari direktori proses PDF ke direktori public
                try:
                    if "original_path" in img_info and os.path.exists(img_info["original_path"]):
                        shutil.copy(img_info["original_path"], original_public_path)
                    if "watermarked_path" in img_info and os.path.exists(img_info["watermarked_path"]):
                        shutil.copy(img_info["watermarked_path"], watermarked_public_path)
                        
                    # Tambahkan ke processed_images dengan path relatif yang benar
                    processed_images.append({
                        "index": img_index,
                        "original": f"generated/{pdf_dir_name}/{original_filename}",
                        "watermarked": f"generated/{pdf_dir_name}/{watermarked_filename}",
                        "individual_metrics": img_info.get("metrics", {})
                    })
                except Exception as e:
                pass
                    continue
            
            # Salin QR Code ke direktori public juga
            qr_filename = "watermark_qr.png"
            qr_public_path = os.path.join(app.config['GENERATED_FOLDER'], pdf_dir_name, qr_filename)
            try:
                shutil.copy(qr_temp_path, qr_public_path)
                qr_image_url = f"generated/{pdf_dir_name}/{qr_filename}"
            except Exception as e:
                pass
                qr_image_url = ""
                
            public_dir = pdf_dir_name
            qr_info = None
            pdf_info = process_result.get("pdf_info", {})
        else:
            # Run the embed_watermark_to_docx function directly to get the processed images
            try:
                process_result = embed_watermark_to_docx(docx_temp_path, qr_temp_path, stego_docx_output_path)
                
                # Get processed images info if available
                processed_images = []
                qr_image_url = ""
                public_dir = ""
                qr_info = None
                pdf_info = None
                
                if isinstance(process_result, dict) and process_result.get("success"):
                    processed_images = process_result.get("processed_images", [])
                    qr_image_url = process_result.get("qr_image", "")
                    public_dir = process_result.get("public_dir", "")
                    qr_info = process_result.get("qr_info", None)
                else:
                    processed_images = []
                    qr_image_url = ""
                    public_dir = ""
                    qr_info = None
                    pdf_info = None
                    
            except ValueError as ve:
                pass
                if str(ve) == "NO_IMAGES_FOUND":
                    # Handle no images case
                    return jsonify({
                        "success": False,
                        "message": "Dokumen ini tidak mengandung gambar",
                        "log": result["stderr"],
                        "error_type": "NO_IMAGES_FOUND"
                    }), 400
                processed_images = []
                qr_image_url = ""
                public_dir = ""
                qr_info = None
                pdf_info = None
            except Exception as e:
                pass
                processed_images = []
                qr_image_url = ""
                public_dir = ""
                qr_info = None
                pdf_info = None
        
        # Hitung MSE dan PSNR
        if not is_pdf:
            metrics = calculate_metrics(docx_temp_path, stego_docx_output_path)
        else:
            # Untuk PDF, gunakan rata-rata dari semua halaman
            metrics = {"mse": 0, "psnr": 0}  # Default values
            if process_result and "analysis" in process_result and "page_analyses" in process_result["analysis"]:
                page_metrics = [p["metrics"] for p in process_result["analysis"]["page_analyses"] if p["metrics"].get("success")]
                if page_metrics:
                    avg_mse = sum(m["mse"] for m in page_metrics) / len(page_metrics)
                    valid_psnr_values = [m["psnr"] for m in page_metrics if m["psnr"] != float('inf')]
                    if valid_psnr_values:
                        avg_psnr = sum(valid_psnr_values) / len(valid_psnr_values)
                    else:
                        avg_psnr = 999.99  # Use high value instead of infinity
                    # Update metrics with calculated values
                    metrics["mse"] = avg_mse
                    metrics["psnr"] = avg_psnr
                else:
                    pass
        
        # Analisis pixel gambar QR dengan detail
        from qr_utils import calculate_mse_psnr, get_detailed_pixel_info
        
        if is_pdf and process_result and "analysis" in process_result:
            # Untuk PDF, gunakan analisis QR dari hasil PDF processing
            qr_analysis = process_result["analysis"].get("qr_analysis", {})
            
            # Gunakan analisis yang sudah ada dari PDF processing
            image_analyses = []
            detailed_metrics = []
            
            # Konversi format analisis PDF ke format yang diharapkan frontend
            for page_analysis in process_result["analysis"].get("page_analyses", []):
                page_num = page_analysis.get("page_number", 0) - 1  # Convert to 0-based index
                image_analyses.append({
                    "image_index": page_num,
                    "original": page_analysis.get("original", {}),
                    "watermarked": page_analysis.get("watermarked", {})
                })
                
                detailed_metrics.append({
                    "image_index": page_num,
                    "metrics": page_analysis.get("metrics", {})
                })
        else:
            qr_analysis = get_detailed_pixel_info(qr_temp_path)
            
            # Analisis gambar yang diproses (jika ada)
            image_analyses = []
            detailed_metrics = []
            if processed_images:
                for i, img_info in enumerate(processed_images):  # Analisis semua gambar
                    if "original_path" in img_info and "watermarked_path" in img_info:
                        # Analisis pixel gambar asli dengan detail
                        original_analysis = get_detailed_pixel_info(img_info["original_path"])
                        
                        # Analisis pixel gambar watermarked dengan detail
                        watermarked_analysis = get_detailed_pixel_info(img_info["watermarked_path"])
                        
                        # MSE/PSNR detail per gambar
                        img_metrics = calculate_mse_psnr(img_info["original_path"], img_info["watermarked_path"])
                        
                        image_analyses.append({
                            "image_index": i,
                            "original": original_analysis,
                            "watermarked": watermarked_analysis
                        })
                        
                        detailed_metrics.append({
                            "image_index": i,
                            "metrics": img_metrics
                        })
                        
                        # Add pixel analysis data and metrics to processed_images for display
                        if i < len(processed_images):
                            processed_images[i]["pixel_analysis"] = {
                                "original": original_analysis,
                                "watermarked": watermarked_analysis
                            }
                            processed_images[i]["individual_metrics"] = img_metrics
        

        # Salin dokumen hasil ke folder documents untuk akses permanen
        try:
            shutil.copy2(stego_docx_output_path, documents_output_path)
        except Exception as e:
                pass

        # Baca data QR code untuk ditampilkan
        qr_data = None
        try:
            qr_data_list = read_qr(qr_temp_path)
            if qr_data_list:
                qr_data = qr_data_list[0]  # Ambil data QR pertama
        except Exception as e:
                pass

        # Hitung perbandingan ukuran file sebelum menghapus file temporary
        processed_size_info = get_file_size_info(stego_docx_output_path)
        
        # Hitung selisih
        size_difference = processed_size_info["bytes"] - original_file_size["bytes"]
        size_change_percentage = (size_difference / original_file_size["bytes"]) * 100 if original_file_size["bytes"] > 0 else 0
        
        # Format perubahan
        if size_difference > 0:
            size_change_text = f"Bertambah {abs(size_change_percentage):.2f}%"
        elif size_difference < 0:
            size_change_text = f"Berkurang {abs(size_change_percentage):.2f}%"
        else:
            size_change_text = "Tidak berubah"

        file_size_info = {
            "original": original_file_size,
            "processed": processed_size_info,
            "difference_bytes": size_difference,
            "difference_percentage": round(size_change_percentage, 2),
            "size_change": size_change_text
        }

        # Hapus file temporary setelah perhitungan metrik
        if os.path.exists(docx_temp_path):
            os.remove(docx_temp_path)
        if os.path.exists(qr_temp_path):
            os.remove(qr_temp_path)

        # Hitung informasi ukuran file
        original_size_info = {
            "bytes": docx_file.content_length or 0,
            "kb": round((docx_file.content_length or 0) / 1024, 2),
            "mb": round((docx_file.content_length or 0) / (1024 * 1024), 2),
            "formatted": f"{(docx_file.content_length or 0) / 1024:.2f} KB" if (docx_file.content_length or 0) >= 1024 else f"{docx_file.content_length or 0} bytes"
        }
        
        # Informasi file hasil
        processed_size_info = get_file_size_info(stego_docx_output_path)
        
        # Hitung perbandingan ukuran file
        original_bytes = original_size_info["bytes"]
        processed_bytes = processed_size_info["bytes"]
        difference_bytes = processed_bytes - original_bytes
        
        if original_bytes > 0:
            difference_percentage = (difference_bytes / original_bytes) * 100
        else:
            difference_percentage = 0
            
        # Tentukan jenis perubahan
        if difference_bytes > 0:
            change_type = "increase"
            change_text = f"+{abs(difference_bytes)} bytes (+{abs(difference_percentage):.2f}%)"
        elif difference_bytes < 0:
            change_type = "decrease"
            change_text = f"-{abs(difference_bytes)} bytes (-{abs(difference_percentage):.2f}%)"
        else:
            change_type = "no-change"
            change_text = "Tidak ada perubahan ukuran"
        
        # Quality assessment berdasarkan persentase perubahan
        if abs(difference_percentage) < 1:
            quality = "Excellent"
            quality_color = "success"
        elif abs(difference_percentage) < 5:
            quality = "Good"
            quality_color = "success"
        elif abs(difference_percentage) < 10:
            quality = "Fair"
            quality_color = "warning"
        else:
            quality = "Poor"
            quality_color = "error"
            
        file_size_comparison = {
            "original": original_size_info,
            "processed": processed_size_info,
            "difference_bytes": difference_bytes,
            "difference_percentage": round(difference_percentage, 2),
            "change_type": change_type,
            "change_text": change_text,
            "quality": quality,
            "quality_color": quality_color
        }
        
        # Hitung selisih
        size_difference = processed_size_info["bytes"] - original_size_info["bytes"]
        size_change_percentage = (size_difference / original_size_info["bytes"]) * 100 if original_size_info["bytes"] > 0 else 0
        
        # Format perubahan
        if size_difference > 0:
            size_change_text = f"Bertambah {abs(size_change_percentage):.2f}%"
        elif size_difference < 0:
            size_change_text = f"Berkurang {abs(size_change_percentage):.2f}%"
        else:
            size_change_text = "Tidak berubah"

        file_size_info = {
            "original": original_size_info,
            "processed": processed_size_info,
            "difference_bytes": size_difference,
            "difference_percentage": round(size_change_percentage, 2),
            "size_change": size_change_text
        }

        response_data = {
            "success": True,
            "message": f"Watermark berhasil disisipkan ke {'PDF' if is_pdf else 'dokumen'}!",
            "download_url": f"/download_generated/{stego_docx_filename}",
            "documents_url": f"/download_documents/{documents_filename}",
            "documents_filename": documents_filename,
            "log": result["stdout"],
            "mse": metrics["mse"],
            "psnr": metrics["psnr"],
            "processed_images": processed_images,
            "qr_image": qr_image_url,
            "public_dir": public_dir,
            "qr_info": qr_info,
            "qr_data": qr_data,
            "analysis": {
                "qr_analysis": qr_analysis,
                "image_analyses": image_analyses,
                "detailed_metrics": detailed_metrics
            },
            "file_type": "pdf" if is_pdf else "docx",
            "original_filename": docx_file.filename,
            "file_size_info": file_size_info
        }
        
        # Tambahkan informasi ukuran file jika tersedia dari process_result
        if process_result and "file_size_info" in process_result:
            response_data["file_size_info"] = process_result["file_size_info"]
        
        # Tambahkan informasi PDF jika relevan
        if is_pdf and 'pdf_info' in locals():
            response_data["pdf_info"] = pdf_info
            response_data["total_pages"] = pdf_info.get("pages", 0)
            response_data["processed_pages"] = len(processed_images)
            
        return jsonify(response_data)
    else:
        # Hapus file temporary jika terjadi error
        if os.path.exists(docx_temp_path):
            os.remove(docx_temp_path)
        if os.path.exists(qr_temp_path):
            os.remove(qr_temp_path)

        # Check for the specific "NO_IMAGES_FOUND" error
        if result["stderr"] and "NO_IMAGES_FOUND" in result["stderr"]:
            return jsonify({
                "success": False,
                "message": "Dokumen ini tidak mengandung gambar",
                "log": result["stderr"],
                "error_type": "NO_IMAGES_FOUND"
            }), 400
        
        return jsonify({
            "success": False,
            "message": "Gagal menyisipkan watermark.",
            "log": result["stderr"] or result.get("error", "Error tidak diketahui")
        }), 500


@app.route('/extract_docx', methods=['POST'])
def extract_docx_route():
    if 'docxFileValidate' not in request.files:
        return jsonify({"success": False, "message": "File Dokumen diperlukan untuk validasi."}), 400

    docx_file = request.files['docxFileValidate']

    if docx_file.filename == '':
        return jsonify({"success": False, "message": "Nama file tidak boleh kosong."}), 400
    if not (docx_file and allowed_file(docx_file.filename, ALLOWED_DOCX_EXTENSIONS)):
        return jsonify({"success": False, "message": "Format Dokumen harus .docx atau .pdf"}), 400

    file_extension = docx_file.filename.rsplit('.', 1)[1].lower()
    docx_validate_filename = f"doc_extract_in_{uuid.uuid4().hex}.{file_extension}"
    docx_temp_path = os.path.join(app.config['UPLOAD_FOLDER'], docx_validate_filename)
    docx_file.save(docx_temp_path)

    # Simpan ukuran file untuk informasi
    original_file_size = get_file_size_info(docx_temp_path)

    extraction_id = uuid.uuid4().hex
    output_extraction_dir_name = f"extraction_{extraction_id}"
    output_extraction_dir_path = os.path.join(app.config['GENERATED_FOLDER'], output_extraction_dir_name)

    # Cek apakah file adalah PDF
    is_pdf = file_extension == 'pdf'
    
    if is_pdf:
        # Proses PDF menggunakan pdf_utils  
        from pdf_utils import extract_watermark_from_pdf_real_images
        
        pdf_result = extract_watermark_from_pdf_real_images(docx_temp_path, output_extraction_dir_path)
        
        if pdf_result.get("success"):
            result = {"success": True, "stdout": "PDF extraction berhasil", "stderr": ""}
            extracted_qrs_info = pdf_result.get("extracted_qrs", [])
        else:
            result = {"success": False, "stdout": "", "stderr": pdf_result.get("message", "PDF extraction gagal")}
            extracted_qrs_info = []
    else:
        # Proses DOCX seperti biasa
        args = ['extract_docx', '--docx', docx_temp_path, '--output_dir', output_extraction_dir_path]
        result = run_main_script(args)
        extracted_qrs_info = []

    if result["success"]:
        if not is_pdf:
            # Untuk DOCX, scan direktori output
            extracted_qrs_info = []
            if os.path.exists(output_extraction_dir_path) and os.path.isdir(output_extraction_dir_path):
                for filename in os.listdir(output_extraction_dir_path):
                    if filename.lower().endswith('.png'):
                        extracted_qrs_info.append({
                            "filename": filename,
                            "url": f"/static/generated/{output_extraction_dir_name}/{filename}"
                        })
        # Untuk PDF, extracted_qrs_info sudah diset dari pdf_result

        if not extracted_qrs_info and "Tidak ada gambar yang ditemukan" not in result["stdout"]:
            pass

        # Hapus file temporary setelah selesai
        if os.path.exists(docx_temp_path):
            os.remove(docx_temp_path)

        response_data = {
            "success": True,
            "message": f"Proses ekstraksi {'PDF' if is_pdf else 'dokumen'} selesai.",
            "extracted_qrs": extracted_qrs_info,
            "log": result["stdout"],
            "file_type": "pdf" if is_pdf else "docx",
            "original_file_size": original_file_size
        }
        
        # Tambahkan informasi PDF jika relevan
        if is_pdf and 'pdf_result' in locals():
            response_data["pdf_info"] = pdf_result.get("pdf_info", {})
            response_data["total_pages"] = pdf_result.get("total_pages", 0)
            response_data["qr_found"] = pdf_result.get("qr_found", 0)
            
        return jsonify(response_data)
    else:
        # Hapus file temporary jika terjadi error
        if os.path.exists(docx_temp_path):
            os.remove(docx_temp_path)

        # Check for the specific "NO_IMAGES_FOUND" error
        if result["stderr"] and "NO_IMAGES_FOUND" in result["stderr"]:
            return jsonify({
                "success": False,
                "message": "Dokumen ini tidak mengandung gambar",
                "log": result["stderr"],
                "error_type": "NO_IMAGES_FOUND"
            }), 400

        return jsonify({
            "success": False,
            "message": "Gagal mengekstrak watermark.",
            "log": result["stderr"] or result.get("error", "Error tidak diketahui")
        }), 500


@app.route('/validate_qr_integrity', methods=['POST'])
def validate_qr_integrity():
    """Validasi integritas QR Code menggunakan CRC32"""
    if 'qrFile' not in request.files:
        return jsonify({"success": False, "message": "File QR Code diperlukan"}), 400
    
    qr_file = request.files['qrFile']
    if qr_file.filename == '':
        return jsonify({"success": False, "message": "Nama file tidak boleh kosong"}), 400
    
    # Simpan file sementara
    temp_filename = f"validate_qr_{uuid.uuid4().hex}.png"
    temp_path = os.path.join(app.config['UPLOAD_FOLDER'], temp_filename)
    qr_file.save(temp_path)
    
    try:
        # Baca QR Code
        qr_data_list = read_qr(temp_path)
        
        if not qr_data_list:
            return jsonify({
                "success": False,
                "message": "Tidak dapat membaca QR Code"
            }), 400
        
        qr_data_raw = qr_data_list[0]
        
        # Parse JSON data
        try:
            qr_data_parsed = json.loads(qr_data_raw)
        except json.JSONDecodeError:
            # QR Code lama tanpa CRC32
            return jsonify({
                "success": True,
                "integrity_check": False,
                "message": "QR Code tidak memiliki CRC32 checksum (format lama)",
                "data": qr_data_raw
            })
        
        # Import fungsi verifikasi
        from qr_utils import verify_crc32_checksum
        
        # Verifikasi CRC32
        is_valid = verify_crc32_checksum(qr_data_parsed)
        
        return jsonify({
            "success": True,
            "integrity_check": True,
            "data_valid": is_valid,
            "message": "Data valid dan tidak rusak" if is_valid else "Data rusak atau dimodifikasi",
            "data": qr_data_parsed.get("data", ""),
            "crc32_info": {
                "stored_checksum": qr_data_parsed.get("crc32"),
                "timestamp": qr_data_parsed.get("timestamp"),
                "status": "VALID" if is_valid else "INVALID"
            }
        })
        
    except Exception as e:
                pass
        return jsonify({
            "success": False,
            "message": f"Error validasi: {str(e)}"
        }), 500
        
    finally:
        # Hapus file sementara
        if os.path.exists(temp_path):
            os.remove(temp_path)


@app.route('/download_generated/<filename>')
def download_generated(filename):
    """Endpoint untuk mengunduh file dari folder generated."""
    return send_from_directory(app.config['GENERATED_FOLDER'], filename, as_attachment=True)


@app.route('/download_documents/<filename>')
def download_documents(filename):
    """Endpoint untuk mengunduh file dari folder documents."""
    return send_from_directory(app.config['DOCUMENTS_FOLDER'], filename, as_attachment=True)


@app.route('/list_documents')
def list_documents():
    """Endpoint untuk melihat daftar dokumen yang tersimpan."""
    try:
        documents = []
        for filename in os.listdir(app.config['DOCUMENTS_FOLDER']):
            if filename.endswith('.docx'):
                file_path = os.path.join(app.config['DOCUMENTS_FOLDER'], filename)
                file_stat = os.stat(file_path)
                documents.append({
                    'filename': filename,
                    'size': file_stat.st_size,
                    'created': file_stat.st_ctime,
                    'download_url': f'/download_documents/{filename}'
                })
        
        # Urutkan berdasarkan waktu pembuatan (terbaru dulu)
        documents.sort(key=lambda x: x['created'], reverse=True)
        
        return jsonify({
            'success': True,
            'documents': documents,
            'count': len(documents)
        })
    except Exception as e:
                pass
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@app.route('/process_details')
def process_details():
    """Render the process details page."""
    return render_template('pixel_viewer.html')


@app.route('/pixel_viewer')
def pixel_viewer():
    """Render the pixel viewer page."""
    return render_template('pixel_viewer.html')


# =============================================================================
# PIXEL VIEWER ENHANCEMENT - API ENDPOINTS
# =============================================================================

@app.route('/api/pixel_data/<path:image_id>/<int:x>/<int:y>/<int:width>/<int:height>')
def get_pixel_region(image_id, x, y, width, height):
    """
    Get pixel data for a specific region of an image.
    
    Args:
        image_id: ID gambar (filename tanpa extension)
        x, y: Koordinat top-left region
        width, height: Ukuran region
    
    Returns:
        JSON dengan data pixel dalam format grid
    """
    try:
        # Cari file gambar berdasarkan image_id
        image_path = None
        search_dirs = [app.config['GENERATED_FOLDER'], app.config['UPLOAD_FOLDER']]
        
        # Handle nested paths like "dir/filename" or just "filename"
        for search_dir in search_dirs:
            for ext in ['png', 'jpg', 'jpeg']:
                # Try direct path first
                potential_path = os.path.join(search_dir, f"{image_id}.{ext}")
                if os.path.exists(potential_path):
                    image_path = potential_path
                    break
                    
                # If not found and contains slash, try without directory nesting
                if '/' in image_id:
                    filename_only = os.path.basename(image_id)
                    potential_path = os.path.join(search_dir, f"{filename_only}.{ext}")
                    if os.path.exists(potential_path):
                        image_path = potential_path
                        break
            if image_path:
                break
                
        # If still not found, search recursively
        if not image_path:
            filename_to_search = os.path.basename(image_id)
            for search_dir in search_dirs:
                for root, dirs, files in os.walk(search_dir):
                    for ext in ['png', 'jpg', 'jpeg']:
                        filename = f"{filename_to_search}.{ext}"
                        if filename in files:
                            potential_path = os.path.join(root, filename)
                            if os.path.exists(potential_path):
                                image_path = potential_path
                                break
                    if image_path:
                        break
                if image_path:
                    break
        
        if not image_path:
            return jsonify({'success': False, 'error': 'Image not found'}), 404
        
        # Load image dan ambil region yang diminta
        image = Image.open(image_path)
        img_array = np.array(image)
        
        # Validasi koordinat
        if x + width > image.width or y + height > image.height:
            return jsonify({'success': False, 'error': 'Region out of bounds'}), 400
        
        # Extract region
        region = img_array[y:y+height, x:x+width]
        
        # Convert ke format yang mudah digunakan frontend
        pixel_data = []
        for row_idx, row in enumerate(region):
            pixel_row = []
            for col_idx, pixel in enumerate(row):
                if len(pixel) >= 3:  # RGB
                    pixel_info = {
                        'x': x + col_idx,
                        'y': y + row_idx,
                        'r': int(pixel[0]),
                        'g': int(pixel[1]),
                        'b': int(pixel[2]),
                        'hex': f"#{pixel[0]:02x}{pixel[1]:02x}{pixel[2]:02x}"
                    }
                    # Add alpha channel if exists
                    if len(pixel) == 4:
                        pixel_info['a'] = int(pixel[3])
                    
                    pixel_row.append(pixel_info)
            pixel_data.append(pixel_row)
        
        return jsonify({
            'success': True,
            'image_id': image_id,
            'region': {'x': x, 'y': y, 'width': width, 'height': height},
            'image_size': {'width': image.width, 'height': image.height},
            'pixel_data': pixel_data
        })
        
    except Exception as e:
                pass
        print(f"Error in get_pixel_region: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/bit_planes/<path:image_id>/<channel>')
def get_bit_planes(image_id, channel):
    """
    Extract bit planes untuk visualisasi LSB.
    
    Args:
        image_id: ID gambar
        channel: 'r', 'g', 'b', atau 'all'
    
    Returns:
        JSON dengan data bit planes
    """
    try:
        # Cari file gambar
        image_path = None
        search_dirs = [app.config['GENERATED_FOLDER'], app.config['UPLOAD_FOLDER']]
        
        # Handle nested paths like "dir/filename" or just "filename"
        for search_dir in search_dirs:
            for ext in ['png', 'jpg', 'jpeg']:
                # Try direct path first
                potential_path = os.path.join(search_dir, f"{image_id}.{ext}")
                if os.path.exists(potential_path):
                    image_path = potential_path
                    break
                    
                # If not found and contains slash, try without directory nesting
                if '/' in image_id:
                    filename_only = os.path.basename(image_id)
                    potential_path = os.path.join(search_dir, f"{filename_only}.{ext}")
                    if os.path.exists(potential_path):
                        image_path = potential_path
                        break
            if image_path:
                break
                
        # If still not found, search recursively
        if not image_path:
            filename_to_search = os.path.basename(image_id)
            for search_dir in search_dirs:
                for root, dirs, files in os.walk(search_dir):
                    for ext in ['png', 'jpg', 'jpeg']:
                        filename = f"{filename_to_search}.{ext}"
                        if filename in files:
                            potential_path = os.path.join(root, filename)
                            if os.path.exists(potential_path):
                                image_path = potential_path
                                break
                    if image_path:
                        break
                if image_path:
                    break
        
        if not image_path:
            return jsonify({'success': False, 'error': 'Image not found'}), 404
        
        # Load image
        image = Image.open(image_path)
        img_array = np.array(image)
        
        channels = {'r': 0, 'g': 1, 'b': 2}
        
        if channel == 'all':
            result = {}
            for ch_name, ch_idx in channels.items():
                if ch_idx < img_array.shape[2]:
                    channel_data = img_array[:, :, ch_idx]
                    bit_planes = []
                    
                    # Extract 8 bit planes (0 = LSB, 7 = MSB)
                    for bit in range(8):
                        bit_plane = (channel_data >> bit) & 1
                        bit_planes.append(bit_plane.tolist())
                    
                    result[ch_name] = bit_planes
            
            return jsonify({
                'success': True,
                'image_id': image_id,
                'channel': 'all',
                'bit_planes': result
            })
        
        elif channel in channels:
            ch_idx = channels[channel]
            if ch_idx >= img_array.shape[2]:
                return jsonify({'success': False, 'error': f'Channel {channel} not available'}), 400
            
            channel_data = img_array[:, :, ch_idx]
            bit_planes = []
            
            # Extract 8 bit planes
            for bit in range(8):
                bit_plane = (channel_data >> bit) & 1
                bit_planes.append(bit_plane.tolist())
            
            return jsonify({
                'success': True,
                'image_id': image_id,
                'channel': channel,
                'bit_planes': bit_planes
            })
        
        else:
            return jsonify({'success': False, 'error': 'Invalid channel'}), 400
            
    except Exception as e:
                pass
        print(f"Error in get_bit_planes: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/pixel_diff/<path:dir1>/<path:img1>/<path:dir2>/<path:img2>')
def get_pixel_difference(dir1, img1, dir2, img2):
    """
    Calculate pixel-wise differences between original and watermarked images.
    
    Args:
        original_id: ID gambar asli
        watermarked_id: ID gambar watermarked
    
    Returns:
        JSON dengan data perbedaan pixel
    """
    try:
        # Reconstruct the full image IDs from the path components
        original_id = f"{dir1}/{img1}"
        watermarked_id = f"{dir2}/{img2}"
        # Function untuk mencari file gambar
        def find_image_path(image_id):
            search_dirs = [app.config['GENERATED_FOLDER'], app.config['UPLOAD_FOLDER']]
            
            # Handle nested paths like "dir/filename" or just "filename"
            for search_dir in search_dirs:
                for ext in ['png', 'jpg', 'jpeg']:
                    # Try direct path first
                    potential_path = os.path.join(search_dir, f"{image_id}.{ext}")
                    if os.path.exists(potential_path):
                        return potential_path
                        
                    # If not found and contains slash, try without directory nesting
                    if '/' in image_id:
                        filename_only = os.path.basename(image_id)
                        potential_path = os.path.join(search_dir, f"{filename_only}.{ext}")
                        if os.path.exists(potential_path):
                            return potential_path
                    
            # If still not found, search recursively
            filename_to_search = os.path.basename(image_id)
            for search_dir in search_dirs:
                for root, dirs, files in os.walk(search_dir):
                    for ext in ['png', 'jpg', 'jpeg']:
                        filename = f"{filename_to_search}.{ext}"
                        if filename in files:
                            potential_path = os.path.join(root, filename)
                            if os.path.exists(potential_path):
                                return potential_path
            return None
        
        original_path = find_image_path(original_id)
        watermarked_path = find_image_path(watermarked_id)
        
        
        if not original_path:
            return jsonify({'success': False, 'error': f'Original image not found for ID: {original_id}'}), 404
        if not watermarked_path:
            return jsonify({'success': False, 'error': f'Watermarked image not found for ID: {watermarked_id}'}), 404
        
        # Load kedua gambar
        original_img = Image.open(original_path)
        watermarked_img = Image.open(watermarked_path)
        
        # Convert ke numpy arrays
        original_array = np.array(original_img)
        watermarked_array = np.array(watermarked_img)
        
        # Pastikan ukuran sama
        if original_array.shape != watermarked_array.shape:
            return jsonify({'success': False, 'error': 'Image dimensions do not match'}), 400
        
        # Hitung perbedaan
        diff_array = watermarked_array.astype(np.int16) - original_array.astype(np.int16)
        
        # Hitung statistik
        total_pixels = original_array.shape[0] * original_array.shape[1]
        changed_pixels = np.sum(np.any(diff_array != 0, axis=2))
        
        # Identifikasi pixel yang berubah
        changed_positions = []
        for y in range(diff_array.shape[0]):
            for x in range(diff_array.shape[1]):
                if np.any(diff_array[y, x] != 0):
                    changed_positions.append({
                        'x': int(x),
                        'y': int(y),
                        'original': {
                            'r': int(original_array[y, x, 0]),
                            'g': int(original_array[y, x, 1]),
                            'b': int(original_array[y, x, 2])
                        },
                        'watermarked': {
                            'r': int(watermarked_array[y, x, 0]),
                            'g': int(watermarked_array[y, x, 1]),
                            'b': int(watermarked_array[y, x, 2])
                        },
                        'diff': {
                            'r': int(diff_array[y, x, 0]),
                            'g': int(diff_array[y, x, 1]),
                            'b': int(diff_array[y, x, 2])
                        }
                    })
        
        # Calculate MSE dan PSNR
        mse = np.mean(diff_array ** 2)
        if mse == 0:
            psnr = float('inf')
        else:
            psnr = 10 * np.log10((255.0 ** 2) / mse)
        
        return jsonify({
            'success': True,
            'original_id': original_id,
            'watermarked_id': watermarked_id,
            'statistics': {
                'total_pixels': int(total_pixels),
                'changed_pixels': int(changed_pixels),
                'change_percentage': float(changed_pixels / total_pixels * 100),
                'mse': float(mse),
                'psnr': float(psnr) if psnr != float('inf') else 999.99
            },
            'changed_positions': changed_positions[:500],  # Limit to first 500 untuk performa tapi cukup untuk visualisasi
            'total_changes': len(changed_positions)
        })
        
    except Exception as e:
                pass
        print(f"Error in get_pixel_difference: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/pixel_inspector/<path:image_id>/<int:x>/<int:y>')
def pixel_inspector(image_id, x, y):
    """
    Get detailed information about a specific pixel.
    
    Args:
        image_id: ID gambar
        x, y: Koordinat pixel
    
    Returns:
        JSON dengan detail pixel termasuk binary representation
    """
    try:
        # Cari file gambar
        image_path = None
        search_dirs = [app.config['GENERATED_FOLDER'], app.config['UPLOAD_FOLDER']]
        
        # Handle nested paths like "dir/filename" or just "filename"
        for search_dir in search_dirs:
            for ext in ['png', 'jpg', 'jpeg']:
                # Try direct path first
                potential_path = os.path.join(search_dir, f"{image_id}.{ext}")
                if os.path.exists(potential_path):
                    image_path = potential_path
                    break
                    
                # If not found and contains slash, try without directory nesting
                if '/' in image_id:
                    filename_only = os.path.basename(image_id)
                    potential_path = os.path.join(search_dir, f"{filename_only}.{ext}")
                    if os.path.exists(potential_path):
                        image_path = potential_path
                        break
            if image_path:
                break
                
        # If still not found, search recursively
        if not image_path:
            filename_to_search = os.path.basename(image_id)
            for search_dir in search_dirs:
                for root, dirs, files in os.walk(search_dir):
                    for ext in ['png', 'jpg', 'jpeg']:
                        filename = f"{filename_to_search}.{ext}"
                        if filename in files:
                            potential_path = os.path.join(root, filename)
                            if os.path.exists(potential_path):
                                image_path = potential_path
                                break
                    if image_path:
                        break
                if image_path:
                    break
        
        if not image_path:
            return jsonify({'success': False, 'error': 'Image not found'}), 404
        
        # Load image
        image = Image.open(image_path)
        img_array = np.array(image)
        
        # Validasi koordinat
        if x >= image.width or y >= image.height:
            return jsonify({'success': False, 'error': 'Coordinates out of bounds'}), 400
        
        # Get pixel data
        pixel = img_array[y, x]
        
        # Create detailed info
        pixel_info = {
            'position': {'x': x, 'y': y},
            'rgb': {
                'r': int(pixel[0]),
                'g': int(pixel[1]),
                'b': int(pixel[2])
            },
            'binary': {
                'r': format(pixel[0], '08b'),
                'g': format(pixel[1], '08b'),
                'b': format(pixel[2], '08b')
            },
            'hex': f"#{pixel[0]:02x}{pixel[1]:02x}{pixel[2]:02x}",
            'lsb': {
                'r': int(pixel[0]) & 1,
                'g': int(pixel[1]) & 1,
                'b': int(pixel[2]) & 1
            }
        }
        
        # Add alpha if exists
        if len(pixel) == 4:
            pixel_info['rgb']['a'] = int(pixel[3])
            pixel_info['binary']['a'] = format(pixel[3], '08b')
            pixel_info['lsb']['a'] = int(pixel[3]) & 1
        
        return jsonify({
            'success': True,
            'image_id': image_id,
            'pixel_info': pixel_info
        })
        
    except Exception as e:
                pass
        print(f"Error in pixel_inspector: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


# =============================================================================
# END PIXEL VIEWER ENHANCEMENT
# =============================================================================


# Menjalankan aplikasi Flask
if __name__ == '__main__':
    ports = [5001, 5002, 5003, 5004, 5005]

    for port in ports:
        try:
            print(f"Mencoba menjalankan aplikasi pada port {port}...")
            app.run(debug=True, host='0.0.0.0', port=port)
            break  # Keluar dari loop jika berhasil
        except OSError as e:
                pass
            if "Address already in use" in str(e):
                print(f"Port {port} sudah digunakan. Mencoba port berikutnya...")
            else:
                print(f"Error: {e}")
                break
    else:
        print("Semua port yang dicoba sudah digunakan. Harap tutup beberapa aplikasi dan coba lagi.")
